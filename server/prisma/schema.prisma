// Landlord Portfolio - Prisma Schema
// PostgreSQL with enums and relations for India + Dubai landlords

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============== ENUMS ==============

enum Country {
  IN  // India
  AE  // UAE / Dubai
  US  // United States
  GB  // United Kingdom
  SG  // Singapore
  SA  // Saudi Arabia
}

enum Currency {
  INR // Indian Rupee
  AED // UAE Dirham
  USD // US Dollar
  GBP // British Pound
  SGD // Singapore Dollar
  SAR // Saudi Riyal
}

enum UnitStatus {
  VACANT
  OCCUPIED
}

enum RentFrequency {
  MONTHLY
  QUARTERLY
  YEARLY
  CUSTOM
}

enum ScheduleStatus {
  DUE
  OVERDUE
  PAID
  PARTIAL
}

enum ChequeStatus {
  RECEIVED
  DEPOSITED
  CLEARED
  BOUNCED
  REPLACED
}

enum PaymentMethod {
  CHEQUE
  BANK_TRANSFER
  UPI
  CASH
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

enum UserRole {
  USER
  SUPER_ADMIN
}

// ============== MODELS ==============

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  name      String?
  mobile    String?
  gender    Gender?
  role      UserRole @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  properties       Property[]
  tenants          Tenant[]
  leases           Lease[]
  cheques          Cheque[]
  payments         Payment[]
}

model Property {
  id             String      @id @default(uuid())
  name           String
  address        String?
  country        Country
  emirateOrState String?     // optional: emirate (Dubai) or state (India)
  currency       Currency
  unitNo         String?     // e.g. "101", "A-2" (one property = one rentable unit)
  bedrooms       Int?
  status         UnitStatus? @default(VACANT)
  notes          String?
  archivedAt     DateTime?   // soft-delete / archive timestamp
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
  ownerId        String

  owner    User             @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  leases   Lease[]
  cheques  Cheque[]
  payments Payment[]
}

model Tenant {
  id         String    @id @default(uuid())
  name       String
  phone      String?
  email      String?
  idNumber   String?   // optional ID (Aadhaar, Emirates ID, etc.)
  notes      String?
  archivedAt DateTime? // soft-delete / archive timestamp
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  ownerId    String

  owner   User    @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  leases  Lease[]
  cheques Cheque[]
  payments Payment[]
}

model Lease {
  id                String        @id @default(uuid())
  startDate         DateTime      @db.Date
  endDate           DateTime      @db.Date
  terminationDate   DateTime?     @db.Date  // when lease was ended early (if before endDate)
  rentFrequency     RentFrequency
  installmentAmount  Decimal       @db.Decimal(14, 2)
  dueDay            Int           // 1-28
  securityDeposit   Decimal?      @db.Decimal(14, 2)
  notes             String?
  archivedAt        DateTime?     // soft-delete / archive timestamp
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  propertyId        String
  tenantId          String
  ownerId           String

  property      Property       @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  tenant        Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  owner         User           @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  rentSchedules RentSchedule[]
  cheques       Cheque[]
  payments      Payment[]
  documents     LeaseDocument[]

  @@index([propertyId, startDate, endDate])
}

model LeaseDocument {
  id               String   @id @default(uuid())
  leaseId          String
  displayName      String?  // optional user-provided name (shown in UI)
  originalFileName String   // original file name from upload
  storedPath       String   // path on disk relative to upload root
  mimeType        String?
  size            Int?     // bytes
  createdAt       DateTime @default(now())

  lease Lease @relation(fields: [leaseId], references: [id], onDelete: Cascade)

  @@index([leaseId])
}

model RentSchedule {
  id             String         @id @default(uuid())
  dueDate        DateTime       @db.Date
  expectedAmount Decimal       @db.Decimal(14, 2)
  paidAmount     Decimal?      @db.Decimal(14, 2)  // for PARTIAL
  status         ScheduleStatus @default(DUE)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  leaseId        String

  lease    Lease     @relation(fields: [leaseId], references: [id], onDelete: Cascade)
  payments PaymentScheduleMatch[]
}

model Cheque {
  id                 String       @id @default(uuid())
  chequeNumber       String
  bankName           String
  chequeDate         DateTime     @db.Date
  amount             Decimal      @db.Decimal(14, 2)
  coversPeriod       String       // e.g. "Feb 2026 Rent"
  status             ChequeStatus @default(RECEIVED)
  depositDate        DateTime?    @db.Date
  clearedOrBounceDate DateTime?   @db.Date
  bounceReason       String?
  notes              String?
  archivedAt         DateTime?    // soft-delete / archive timestamp
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt
  // Denormalized for filters
  leaseId            String
  tenantId           String
  propertyId         String
  ownerId            String
  replacedByChequeId String?      @unique // when status = REPLACED, link to new cheque

  lease    Lease    @relation(fields: [leaseId], references: [id], onDelete: Cascade)
  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  owner    User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  replacedBy      Cheque?  @relation("ChequeReplacement", fields: [replacedByChequeId], references: [id])
  replacesCheque  Cheque?  @relation("ChequeReplacement")
}

model Payment {
  id         String        @id @default(uuid())
  date       DateTime      @db.Date
  amount     Decimal       @db.Decimal(14, 2)
  method     PaymentMethod
  reference  String?
  notes      String?
  archivedAt DateTime?     // soft-delete / archive timestamp
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  leaseId    String
  tenantId   String
  propertyId String
  ownerId    String
  chequeId   String?

  lease    Lease    @relation(fields: [leaseId], references: [id], onDelete: Cascade)
  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  owner    User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  scheduleMatches PaymentScheduleMatch[]
}

// Many-to-many: Payment (or cleared cheque) can match one or more RentSchedule entries
model PaymentScheduleMatch {
  id             String       @id @default(uuid())
  amount         Decimal      @db.Decimal(14, 2)  // amount applied to this schedule
  createdAt      DateTime     @default(now())
  paymentId      String
  rentScheduleId String

  payment      Payment      @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  rentSchedule RentSchedule @relation(fields: [rentScheduleId], references: [id], onDelete: Cascade)

  @@unique([paymentId, rentScheduleId])
}

/// Platform-wide configuration managed by super admins.
model PlatformSettings {
  /// Always use a single row with id = 1
  id               Int      @id @default(1)
  /// Enabled country codes (subset of Country enum values)
  enabledCountries String[]
  /// Enabled currency codes (subset of Currency enum values)
  enabledCurrencies String[]
  updatedAt        DateTime @updatedAt
}
