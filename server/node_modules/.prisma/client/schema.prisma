// Landlord Portfolio - Prisma Schema
// PostgreSQL with enums and relations for India + Dubai landlords

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============== ENUMS ==============

enum Country {
  IN // India
  AE // UAE / Dubai
}

enum Currency {
  INR
  AED
}

enum UnitStatus {
  VACANT
  OCCUPIED
}

enum RentFrequency {
  MONTHLY
  QUARTERLY
  YEARLY
  CUSTOM
}

enum ScheduleStatus {
  DUE
  OVERDUE
  PAID
  PARTIAL
}

enum ChequeStatus {
  RECEIVED
  DEPOSITED
  CLEARED
  BOUNCED
  REPLACED
}

enum PaymentMethod {
  CHEQUE
  BANK_TRANSFER
  UPI
  CASH
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

// ============== MODELS ==============

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  name      String?
  mobile    String?
  gender    Gender?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  properties Property[]
  tenants    Tenant[]
  leases     Lease[]
  cheques    Cheque[]
  payments   Payment[]
}

model Property {
  id             String   @id @default(uuid())
  name           String
  address        String?
  country        Country
  emirateOrState String? // optional: emirate (Dubai) or state (India)
  currency       Currency
  notes          String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  ownerId        String

  owner    User      @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  units    Unit[]
  leases   Lease[]
  cheques  Cheque[]
  payments Payment[]
}

model Unit {
  id         String     @id @default(uuid())
  unitNo     String // e.g. "101", "A-2"
  bedrooms   Int?
  status     UnitStatus @default(VACANT)
  notes      String?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  propertyId String

  property Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  leases   Lease[]
  cheques  Cheque[]
  payments Payment[]
}

model Tenant {
  id        String   @id @default(uuid())
  name      String
  phone     String?
  email     String?
  idNumber  String? // optional ID (Aadhaar, Emirates ID, etc.)
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ownerId   String

  owner    User      @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  leases   Lease[]
  cheques  Cheque[]
  payments Payment[]
}

model Lease {
  id                String        @id @default(uuid())
  startDate         DateTime      @db.Date
  endDate           DateTime      @db.Date
  rentFrequency     RentFrequency
  installmentAmount Decimal       @db.Decimal(14, 2)
  dueDay            Int // 1-28
  securityDeposit   Decimal?      @db.Decimal(14, 2)
  notes             String?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  propertyId        String
  unitId            String
  tenantId          String
  ownerId           String

  property      Property       @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  unit          Unit           @relation(fields: [unitId], references: [id], onDelete: Cascade)
  tenant        Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  owner         User           @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  rentSchedules RentSchedule[]
  cheques       Cheque[]
  payments      Payment[]

  @@index([unitId, startDate, endDate])
}

model RentSchedule {
  id             String         @id @default(uuid())
  dueDate        DateTime       @db.Date
  expectedAmount Decimal        @db.Decimal(14, 2)
  paidAmount     Decimal?       @db.Decimal(14, 2) // for PARTIAL
  status         ScheduleStatus @default(DUE)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  leaseId        String

  lease    Lease                  @relation(fields: [leaseId], references: [id], onDelete: Cascade)
  payments PaymentScheduleMatch[]
}

model Cheque {
  id                  String       @id @default(uuid())
  chequeNumber        String
  bankName            String
  chequeDate          DateTime     @db.Date
  amount              Decimal      @db.Decimal(14, 2)
  coversPeriod        String // e.g. "Feb 2026 Rent"
  status              ChequeStatus @default(RECEIVED)
  depositDate         DateTime?    @db.Date
  clearedOrBounceDate DateTime?    @db.Date
  bounceReason        String?
  notes               String?
  createdAt           DateTime     @default(now())
  updatedAt           DateTime     @updatedAt
  // Denormalized for filters
  leaseId             String
  tenantId            String
  propertyId          String
  unitId              String
  ownerId             String
  replacedByChequeId  String?      @unique // when status = REPLACED, link to new cheque

  lease          Lease    @relation(fields: [leaseId], references: [id], onDelete: Cascade)
  tenant         Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  property       Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  unit           Unit     @relation(fields: [unitId], references: [id], onDelete: Cascade)
  owner          User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  replacedBy     Cheque?  @relation("ChequeReplacement", fields: [replacedByChequeId], references: [id])
  replacesCheque Cheque?  @relation("ChequeReplacement")
}

model Payment {
  id         String        @id @default(uuid())
  date       DateTime      @db.Date
  amount     Decimal       @db.Decimal(14, 2)
  method     PaymentMethod
  reference  String?
  notes      String?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  leaseId    String
  tenantId   String
  propertyId String
  unitId     String
  ownerId    String
  chequeId   String?

  lease           Lease                  @relation(fields: [leaseId], references: [id], onDelete: Cascade)
  tenant          Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  property        Property               @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  unit            Unit                   @relation(fields: [unitId], references: [id], onDelete: Cascade)
  owner           User                   @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  scheduleMatches PaymentScheduleMatch[]
}

// Many-to-many: Payment (or cleared cheque) can match one or more RentSchedule entries
model PaymentScheduleMatch {
  id             String   @id @default(uuid())
  amount         Decimal  @db.Decimal(14, 2) // amount applied to this schedule
  createdAt      DateTime @default(now())
  paymentId      String
  rentScheduleId String

  payment      Payment      @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  rentSchedule RentSchedule @relation(fields: [rentScheduleId], references: [id], onDelete: Cascade)

  @@unique([paymentId, rentScheduleId])
}
